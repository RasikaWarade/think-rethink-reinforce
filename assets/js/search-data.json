{
  
    
        "post0": {
            "title": "Message Passing in Chrome Extension MV3",
            "content": "A chrome extension is made up of multiple components, each with its own scope/functionality regarding what it can do in the browser. Example, . Background script : Listen to events happening in the extension, which covers all Chrome windows. | Popup script: A web page that knows information about Chrome tabs. | Content script: Read and modify the DOM of the current web page in the browser. | . Ref: Chrome Extension Architecture . As each has its own scope, chrome extensions may or may not require information on each scope depending on the use case. Through chrome’s message passing, you can move information from one scope to another. . Here’s how each message looks consolidated. . You will need a listener: chrome.runtime.onMessage.addListener | Depending on who is sending the message and to where, use : chrome.tabs.sendMessage | chrome.runtime.sendMessage | . | Between Background and Popup scripts . Popup to Background . popup.js . //Sending message chrome.runtime.sendMessage({ message: &#39;user_signed_in&#39;, payload: confirmState }, // callback response to the request function (response) { if (response.message === &#39;success&#39; &amp;&amp; confirmState) { //user is signed in , do something } } ); . background.js . //Listening to Messages chrome.runtime.onMessage.addListener(function (request, sender, sendResponse) { if (request.message === &#39;user_signed_in&#39;) { // do something //callback reponse sent sendResponse({ message: &#39;success&#39; }); } return true; }); . Background to Popup . background.js . chrome.runtime.sendMessage({ msg: &quot;something_completed&quot;, data: { subject: &quot;Loading&quot;, content: &quot;Just completed!&quot; } }); . popup.js . chrome.runtime.onMessage.addListener( function(request, sender, sendResponse) { if (request.msg === &quot;something_completed&quot;) { // To do something console.log(request.data.subject) console.log(request.data.content) } } ); . Ref: Stackoverflow Link . Between Background and Content scripts . Content to Background . content.js . chrome.runtime.sendMessage({greeting: &quot;hello&quot;}, function(response) { console.log(response.farewell); }); . background.js . chrome.runtime.onMessage.addListener( function(request, sender, sendResponse) { console.log(sender.tab ? &quot;from a content script:&quot; + sender.tab.url : &quot;from the extension&quot;); if (request.greeting === &quot;hello&quot;) sendResponse({farewell: &quot;goodbye&quot;}); } ); . Ref: Chrome Message Passing . Background to Content . background.js . chrome.tabs.query({active: true, currentWindow: true}, function(tabs){ const activeTab= tabs[0] //Sending message to active Tab chrome.tabs.sendMessage(activeTab.id, { message: &quot;start&quot; }, //callback response function (response) { if (response.message === &#39;success&#39;) { console.log(&quot;success!!&quot;) } } ); }; . content.js . //Listening to Messages chrome.runtime.onMessage.addListener(function (request, sender, sendResponse) { if (request.message === &#39;start&#39;) { //callback response to request sendResponse({ message : &#39;success&#39; }); } return true; }); . Between Popup and Content scripts . Popup to Content . popup.js . chrome.tabs.query({active: true, currentWindow: true}, function(tabs){ let activeTab = tabs[0]; //Sending message to active Tab chrome.tabs.sendMessage(activeTab.id,{ message: &#39;get_details&#39; }, //callback function (response) { if (response.message === &#39;success&#39;) { console.log(&quot;success!!&quot;) } }); }) . content.js . //Listening to Messages chrome.runtime.onMessage.addListener(function (request, sender, sendResponse) { if (request.message === &#39;get_details&#39;) { //callback response to request sendResponse({ message : &#39;success&#39; }); } return true; }); . Content to Popup . content.js . chrome.runtime.sendMessage({greeting: &quot;hello&quot;}, function(response) { console.log(response.farewell); }); . popup.js . chrome.runtime.onMessage.addListener( function(request, sender, sendResponse) { console.log(sender.tab ? &quot;from a content script:&quot; + sender.tab.url : &quot;from the extension&quot;); if (request.greeting === &quot;hello&quot;) sendResponse({farewell: &quot;goodbye&quot;}); } ); . Ref: Chrome Message Passing . Some Gotchas! . Sync and Async Operations . The sendResponse in the Content to Popup implementation is behaving synchronous. | To use sendReponse asynchronously, use return true; as in the Popup to Content implementation. | . Promises . If you are waiting on some callback function result which is asynchronous, you can wrap the operation in a promise. . Example, waiting on the getting active tab information from chrome.tabs, to send the message from background to content. Without a promise, the message response may not be captured by background. Make the changes like below: . //Follow Promise style function getActiveTab() { return new Promise((resolve, reject) =&gt; { try { chrome.tabs.query({ active: true, currentWindow: true }, function (tabs) { resolve(tabs[0]); }); } catch (e) { reject(e); } }) } . let activeTabPromise = getActiveTab() Promise.all([activeTabPromise]) .then(result =&gt; { const activeTab = result[0] //Sending message to active Tab chrome.tabs.sendMessage(activeTab.id, { message: &quot;start&quot; }, //callback response function (response) { if (response.message === &#39;success&#39;) { console.log(&quot;success!!&quot;) } } ); }); .",
            "url": "https://rasikawarade.github.io/think-rethink-reinforce/chrome-extension/javascript/2022/02/21/chrome-messaging.html",
            "relUrl": "/chrome-extension/javascript/2022/02/21/chrome-messaging.html",
            "date": " • Feb 21, 2022"
        }
        
    
  
    
        ,"post1": {
            "title": "Building Chrome Extension with Firebase SDK 9",
            "content": "Firebase SDK 9 + Google Sign In + Chrome Extension Manifest Version 3 + Webpack . Boilerplate Code Brief . The Chrome Extension with MV3 version shows example of authentication of Firebase SDK9 with Google Sign In enable. This boilerplate uses Webpack to speed up the process of writing modular Javascript code, loading HTML and CSS easily, and automatic reload the browser based on changes. . Find the codebase in the github link here. . Why? . As per the Chrome Extension Timeline, all extensions supporting Manifest Version v2 will sunset in Jan 2023, and for new extensions, it has now become a requirement to move to Manifest Version V3. . Google Chrome Extension Manifest v3’s most significant security change is that remotely hosted code, such as Javascript, is now not allowed. If your extension codebase is not bundled and structured in a modular fashion, this can lead to problems. A beginner like me will definitely have a hard time building a setup like that without any guideline. . When I built my Chrome Extension, I had limited experience with webpack, and I believe that new beginners may have the same issue, which is why I decided to compile this resource. . Firebase . Including Firebase libraries is an example. . There are lots of changes already from moving MV2 to MV3 version for chrome extension. At the same time, firebase latest version suggests using SDK9 which needs module bundler support. . For a begineer, you can start with the Firebase quickstart guide but it currently it is incomplete and does not include examples for SDK9. I could not find any quickstart guideline with SDK9 support with Chrome Extension and also hit few issues while following along some of the official documentation, that I will list down below going over the documentation. . As of today 31, Jan 2022, the documentation support for including firebase SDK9 in Chrome Extension is still confusing. With this repo, I have made it work for my use case to enable Google Sign In and ( you can extend the logic for other sign in methods) by combining the resources / code snippets and hopefully it will help someone, moving to Chrome Extension MV3 version this year. . Issues I have hit: . As a beginner I would have preferred using their built in sign in firebase-ui library, FirebaseUI functionality. I can confirm this does not work at the moment, as this library does not support the optimizations of module bundling. | I have tried and it does not work for signInWithPopup and signInWithRedirect functionalities for Google Sign In due to the limitations on the Chrome Extension MV3 side. | . Before you begin . Make sure you have followed the steps to create and register Firebase project/app as below: . Create a Firebase project and register your app | Enable Google Sign-In in the Firebase console: In the Firebase console, open the Auth section. On the Sign in method tab, enable the Google sign-in method and click Save. | Authenticate with Firebase in a Chrome extension as here | References: . Google Sign In | Configure Firebase App | . Demo . Structure . I am assuming you have followed the steps to add Firebase Authentication to your web application and have access to Firebase console. . I am assuming you have taken look for introduction at the Chrome Extension docs and Webpack docs. . Also, if you are beginner, I am assuming you probably would have worked on the Getting Started Guide for extension. If not, I would give a quick look at it as well. . This repo bundles the code explained in the Getting Started Guide with Webpack. . Initial Setup . Make sure you have latest Node.js installed. . My current version: . (base) ➜ ✗ node --version v16.13.1 (base) ➜ ✗ npm --version 8.1.2 . For the initial setup, below webpack bundles were installed: . npm install --save-dev webpack webpack-cli html-webpack-plugin clean-webpack-plugin copy-webpack-plugin . For the Firebase setup, below webpack bundles were installed: . npm install firebase firebaseui --save . Configuration . webpack.development.js . For Development Purposes, you can configure this script and run the command npm run build to reflect changes. . webpack.production.js . For production release, you can configure this script and run the command npm run release to reflect changes. . webpack.common.js . This script contains all the common bundler config common between development and production scripts above. . src . All your extension’s development code must be placed in src folder, including the extension manifest. . The boilerplate is already prepared to have a popup, a options page and a background page. You can easily customize this. . Includes: . background.js | content.js | popup (js + html + css) | options (js + html) | . src/manifest.json . This is the entry point for your extension. | Added “identity” to permission to support authenticate operations. | Fill the OAuth details in the manifest, which are custom to your project /app. If you are not sure, follow the quickstart guide on setting up a sample. | . &quot;oauth2&quot;: { &quot;client_id&quot;: &quot;&lt;fill-me&gt;.apps.googleusercontent.com&quot;, &quot;scopes&quot;: [ &quot;https://www.googleapis.com/auth/userinfo.email&quot;, &quot;https://www.googleapis.com/auth/userinfo.profile&quot; ] }, &quot;key&quot;: &quot;--BEGIN PUBLIC KEY-- n&lt;fill-me&gt; n--END PUBLIC KEY--&quot; . src/popup/firebase_config.js . This is the firebase config script, and you can referrence this in any other javascript by import statement. . import { firebaseApp } from &#39;./firebase_config&#39; . Fill the details for your config, which you get after registering the Firebase app . // config after registering firebase App const config = { apiKey: &quot;&lt;fill-me&gt;&quot;, authDomain: &quot;&lt;fill-me&gt;&quot;, projectId: &quot;&lt;fill-me&gt;&quot;, storageBucket: &quot;&lt;fill-me&gt;&quot;, messagingSenderId: &quot;&lt;fill-me&gt;&quot;, appId: &quot;&lt;fill-me&gt;&quot;, measurementId: &quot;&lt;fill-me&gt;&quot; }; . To provide Google Sign In, the code below used authorizes Firebase (GoogleAuthProvider) with the OAuth Access Token, which will build Firebase credential with the Google ID token. . Code Snippet: . const credential = GoogleAuthProvider.credential(null, token); signInWithCredential(auth, credential).then((result) =&gt; { console.log(&quot;Success!!!&quot;) }).catch((error) =&gt; { . How to use it . Clone the repo | Fill all the details for Firebase App (Secrets) by replacing &lt;fill-me&gt; strings | Find these details as explained above | Run command npm install to install all node-modules / dependencies | Run command npm run build | This will build the dist folder | Load your extension on Chrome following: Access chrome://extensions/ | Check Developer mode | Click on Load unpacked extension | Select the dist folder | | Note: gitignore will help ignore the node_modules and dist folder to be pushed to the github . What’s Next! . Feel free to use this template as boilerplate and a starting point to enable one form of sign in method. Feel free to clone and update as per your own requirements to enable other sign-in methods like Github. .",
            "url": "https://rasikawarade.github.io/think-rethink-reinforce/chrome-extension/firebase/webpack/javascript/2022/02/06/firebase-auth-chrome-webpack.html",
            "relUrl": "/chrome-extension/firebase/webpack/javascript/2022/02/06/firebase-auth-chrome-webpack.html",
            "date": " • Feb 6, 2022"
        }
        
    
  
    
        ,"post2": {
            "title": "Building Chrome Extension with Webpack Bundler",
            "content": "Chrome Extension Manifest Version 3 + Webpack . Boilerplate Code . Find the codebase in the github link here. . The Chrome Extension boilerplate uses Webpack to speed up the process of writing modular Javascript code, loading HTML and CSS easily, and automatically refresh the browser based on changes. . Why? . As per the Chrome Extension Timeline, all extensions supporting Manifest Version v2 will sunset in Jan 2023, and for new extensions, it has now become a requirement to move to Manifest Version V3. . Google Chrome Extension Manifest v3’s most significant security change is that remotely hosted code, such as Javascript, is now not allowed. If your extension codebase is not bundled and structured in a modular fashion, this can lead to problems. A beginner like me will definitely have a hard time building a setup like that without any guideline. . When I built my Chrome Extension, I had limited experience with webpack, and I believe that new beginners may have the same issue, which is why I decided to compile this resource. . Structure . I am assuming you have taken look for introduction at the Chrome Extension docs and Webpack docs. . Also, if you are beginner, I am assuming you probably would have worked on the Getting Started Guide for extension. If not, I would give a quick look at it as well. . This repo bundles the code explained in the Getting Started Guide with Webpack. . Initial Setup . Make sure you have latest Node.js installed. . My current version: . (base) ➜ chrome-extension-mv3-webpack-boilerplate git:(main) ✗ node --version v16.13.1 (base) ➜ chrome-extension-mv3-webpack-boilerplate git:(main) ✗ npm --version 8.1.2 . Configuration . For the initial setup, below webpack bundles were installed: . npm install --save-dev webpack webpack-cli html-webpack-plugin clean-webpack-plugin copy-webpack-plugin . webpack.development.js . For Development Purposes, you can configure this script and run the command npm run build to reflect changes. . webpack.production.js . For production release, you can configure this script and run the command npm run release to reflect changes. . webpack.common.js . This script contains all the common bundler config common between development and production scripts above. . src . All your extension’s development code must be placed in src folder, including the extension manifest. . The boilerplate is already prepared to have a popup, a options page and a background page. You can easily customize this. . Includes: . background.js | content.js | popup (js + html + css) | options (js + html) | . src/manifest.json . This is the entry point for your extension. . { &quot;manifest_version&quot;: 3, &quot;version&quot;: &quot;0.1&quot;, &quot;name&quot;: &quot;MV3 Extension with Webpack&quot;, &quot;description&quot;: &quot;Webpack Modular Framework!&quot;, &quot;action&quot;: { &quot;default_popup&quot;: &quot;./popup.html&quot;, &quot;default_icon&quot;: { &quot;16&quot;: &quot;./src/icons/get_started16.png&quot;, &quot;32&quot;: &quot;./src/icons/get_started32.png&quot;, &quot;48&quot;: &quot;./src/icons/get_started48.png&quot;, &quot;128&quot;: &quot;./src/icons/get_started128.png&quot; }, &quot;default_title&quot;: &quot;Getting Started MV3!&quot; }, &quot;permissions&quot;: [ &quot;storage&quot;, &quot;activeTab&quot;, &quot;scripting&quot; ], &quot;content_scripts&quot;: [ { &quot;matches&quot;: [ &quot;&lt;all_urls&gt;&quot; ], &quot;js&quot;: [ &quot;content.js&quot; ] } ], &quot;background&quot;: { &quot;service_worker&quot;: &quot;background.js&quot; }, &quot;icons&quot;: { &quot;16&quot;: &quot;./src/icons/get_started16.png&quot;, &quot;32&quot;: &quot;./src/icons/get_started32.png&quot;, &quot;48&quot;: &quot;./src/icons/get_started48.png&quot;, &quot;128&quot;: &quot;./src/icons/get_started128.png&quot; }, &quot;options_page&quot;: &quot;options.html&quot; } . How to use it . Clone the repo | Run command npm install to install all node-modules / dependencies | Run command npm run build | This will build the dist folder | Load your extension on Chrome following: Access chrome://extensions/ | Check Developer mode | Click on Load unpacked extension | Select the dist folder | | Note: gitignore will help ignore the node_modules and dist folder to be pushed to the github . What’s Next! . Feel free to use this template as boilerplate and update as per your own requirements. As I mentioned this bundling would help when you want to access some remotely hosted code / libraries, and in my next blog you will see an example of how I utilized it. .",
            "url": "https://rasikawarade.github.io/think-rethink-reinforce/chrome-extension/webpack/javascript/2022/01/30/chrome-webpack.html",
            "relUrl": "/chrome-extension/webpack/javascript/2022/01/30/chrome-webpack.html",
            "date": " • Jan 30, 2022"
        }
        
    
  
    
        ,"post3": {
            "title": "Hacking Growth",
            "content": ":rocket: . A collection of thoughts and ideas is offered in this book , “Hacking Growth by Sean Ellis and Morgan Brown”, as well as various examples of how companies have managed to hack their growth. The author explains why hacking growth strategy is more effective when cross-functional teams such as Marketers, Engineers, Product, Data Scientist and Managers from different disciplines work together rather than as separate teams. It gives some suggestions for how a startup or large company could structure their departments for a cross-functional team like that. . As a business, you strive to increase revenue. Considering all the options that are available, how do you make sure to focus your team efforts and marketing dollars wisely, so as to maximize monetization/revenue, and get more lifetime value for your user? The steps involved in developing such a strategy and different components around this and what to watch out for during this process are discussed. . In this book, you will also learn how to design experiments on different sides of the user journey and how to prioritize as some experiments fail. It makes you realize the importance of getting the strategy right to avoid growth stalls. . First, knowing your growth levers will set you up for success. . Next, tailor your growth levers to fit the needs of your customers, products, and business. . Finally, build a Mantra : . “Hacking growth is a vicious cycle of experimenting and optimizing these growth levers.” . Thoughts . To keep in mind . Aha moment! | Product Core a MUST HAVE | Understand Customer Behaviour to make the product a MUST HAVE | Be Data Driven | Take Experimental Approach | Prioritized | . Thinking about Product Launch . .",
            "url": "https://rasikawarade.github.io/think-rethink-reinforce/marketing/book-read/2022/01/29/hacking-growth.html",
            "relUrl": "/marketing/book-read/2022/01/29/hacking-growth.html",
            "date": " • Jan 29, 2022"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "Connecting dots… . . . Blogs that continue to evolve in thoughts, rethinking and reinforcing the learnings. . Author . . Hello :wave: , I’m Rasika Warade, and currently from New York - New Jersey area, USA. . I am professionally a developer @ Shopify. I have an eclectic range of interests, and this blog would serve as an opportunity to share and learn about those interests. I enjoy coffee :coffee: , driving :car: , and comfort food :rice:. The secret you will discover about me ,only later, is mostly that I love singing :microphone: and dancing :dancer:. . It’s my goal to learn :books: and write :pencil2: in public this year, and I’m so excited about it. I had aimed at it in 2021 and it wasn’t my year for creation, but so far, 2022 looks promising :high_brightness: . . Hope you find these readings delightful and helps a tiny little bit in your own learnings. . Feel free to share comments, any feedback or just connect with me at LinkedIn. . Check out my work at Github or other site. .",
          "url": "https://rasikawarade.github.io/think-rethink-reinforce/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  
      ,"page2": {
          "title": "CodeChallenges",
          "content": "Redirecting to Code Challenges Page... Redirecting to Code Challenges Page...",
          "url": "https://rasikawarade.github.io/think-rethink-reinforce/_pages/code_challenges.html",
          "relUrl": "/_pages/code_challenges.html",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page11": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://rasikawarade.github.io/think-rethink-reinforce/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}